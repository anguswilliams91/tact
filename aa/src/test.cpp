#include <Python.h>
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include "GSLInterface/GSLInterface.h"
#include "gnuplot/gnuplot_i.h"
#include <gsl/gsl_poly.h>
#include "falPot.h"
#include "utils.h"
#include "coordsys.h"
#include "coordtransforms.h"
#include "potential.h"
#include "orbit.h"
#include "stackel_aa.h"
#include "tables_aa.h"
#include "lmn_orb.h"
#include "it_torus.h"
#include "debug.h"
#include "adiabatic_aa.h"

void testDelta(){
	// Finds best Delta for orbits by minimising the spread in actions
	NFW nfw(10.,12.3e5,0.95,0.85);
	lmn_orb lmn(&nfw);
	lmn.readDeltagrids("Delta_withE.dat");
	double ymax = 10.;
	double E = nfw.Phi({0.,ymax,0.});std::cout<<E<<std::endl;
	lmn.findDelta_interp(E);
	std::ofstream outfile; outfile.open("delta_fiddle_lower.dat");
	for(double y = 0.3234;y<ymax;y+=0.5){
	for(double theta = 0.1;theta<3.141/2.;theta+=0.1){
		// double theta = 0.5;
		VecDoub X = {0.01,y,0.01};
		double p = sqrt(2.*E-2.*nfw.Phi(X));
		X.push_back(p*cos(theta));X.push_back(0.05);X.push_back(p*sin(theta));
		VecDoub LMN = lmn.find_best_alphabeta(X);
		outfile<<y<<" "<<theta<<" "<<LMN[0]<<" "<<LMN[1]<<std::endl;
		}
	}
	outfile.close();
}

void test_actions(bool freq_yes){
	// Systematically calculates the spread in the actions for orbits
	// of constant energy
	double m0 = 1.;double fac = 1.;
	NFW nfw(m0,1.,0.95,0.85);
	lmn_orb lmn(&nfw);
	lmn.readDeltagrids("Delta_withE.dat");
	double E = nfw.Phi({0.,m0*fac,0.});//std::cout<<E<<std::endl;
	lmn.findDelta_interp(E);
	std::ofstream orbits;
	orbits.open("../triaxial_stackel_fudge/data/orbits_scaled_withfreq_median_5m0.dat");
	for(double y = 0.1;y<m0*fac;y+=(m0*fac-0.1)/20){
	for(double theta = 0.1;theta<3.141/2.;theta+=0.1){
		VecDoub X = {0.001,y,0.001};
		double p = sqrt(2.*E-2.*nfw.Phi(X));
		X.push_back(p*cos(theta));X.push_back(0.05);X.push_back(p*sin(theta));
		std::cout<<y<<" "<<X[3]<<" "<<X[5]<<" ";
		lmn.actions(X);
		// Orbit orbit_NFW(&nfw);
		// VecDoub QQ=orbit_NFW.integrate(X, 10.5, 0.005);
		// VecDoub LMN = {0.,0.}; //lmn.actionSD(orbit_NFW.results(),freq_yes);
		// orbits<<y<<" "<<theta<<" ";
		// for(auto i:LMN)orbits<<i<<" ";orbits<<std::endl;
	}}
	orbits.close();
}

void testLoop(double y, double theta, std::string filename){
	// Finds action estimates from Stackel fudge for points
	// around an orbit

	NFW nfw(10.,12.3e5,0.95,0.85);
	lmn_orb lmn(&nfw);
	lmn.readDeltagrids("Delta_withE.dat");
	double E = nfw.Phi({0.,10.,0.});std::cout<<E<<std::endl;
	lmn.findDelta_interp(E);
	VecDoub X = {0.01,y,0.01};
	double p = sqrt(2.*E-2.*nfw.Phi(X));
	X.push_back(p*cos(theta));X.push_back(0.05);X.push_back(p*sin(theta));
	Orbit orbit_NFW(&nfw);
	VecDoub QQ=orbit_NFW.integrate(X, 10.5, 0.005);

	// lmn.alphabeta_grid(X);

	VecDoub ab = lmn.find_best_alphabeta(X);
	printVector(X);
	return;
	// std::cout<<sqrt(ab[1]-ab[0])<<" "<<sqrt(-1.-ab[1])<<std::endl;

	std::ofstream outFile; outFile.open(filename);
	for(auto j:orbit_NFW.results()){for(auto i:j)outFile<<i<<" ";
	for(auto i:lmn.actions(j))outFile<<i<<" "; // Uses closed loops
	for(auto i:lmn.actions(j,&ab))outFile<<i<<" "; // From minimization
	for(auto i:lmn.angles(j,&ab))outFile<<i<<" "; // Uses closed loops
	outFile<<std::endl;}
	outFile.close();
}

void runLoops(){
	// testLoop(4.8234,0.4,"../triaxial_stackel_fudge/testloop_v1_with_angles.dat");
	// testLoop(1.8234,0.6,"../triaxial_stackel_fudge/testloop_v2_with_angles.dat");
	testLoop(3.8234,1.2,"../triaxial_stackel_fudge/testloop_v3_with_angles.dat");
	// testLoop(8.3234,1.4,"../triaxial_stackel_fudge/testloop_v4_with_angles.dat");
}

void sos(double y,double theta, std::string file, int comp, int generate){

	// Finds surface of section for orbit,
	// and those generated by the Stackel fudge around the orbit

	NFW nfw(10.,12.3e5,0.95,0.85);
	double E = nfw.Phi({0.,10.,0.});
	VecDoub X = {0.01,y,0.01};
	double p = sqrt(2.*E-2.*nfw.Phi(X));
	X.push_back(p*cos(theta));X.push_back(0.05);X.push_back(p*sin(theta));

	Orbit orbit_NFW(&nfw);

	std::string outfile_orbit = file+"_sos.dat";
	std::string outfile_lmn = file+"_sos2.dat";
	std::ofstream out;out.open(outfile_lmn);out.close();

	std::cerr<<"Generating SoS from orbit...\n";
	if(generate) orbit_NFW.SoS(comp,X,outfile_orbit);

	std::cerr<<"Generating SoS from fudge...\n";
	lmn_orb lmn(&nfw);
	lmn.readDeltagrids("Delta_withE.dat");
	X = orbit_NFW.integrate(X, 10.5, 0.2);
	for(auto i: orbit_NFW.results()) lmn.sos(comp,i,outfile_lmn);
}

void runSoS(){
	// sos(5.8234,0.4,"../triaxial_stackel_fudge/testloop_v1",0,1);
	// sos(5.8234,0.4,"../triaxial_stackel_fudge/testloop_v1.1",1,1);
	sos(1.8234,0.2,"../triaxial_stackel_fudge/testloop_v2_2",0,1);
	// sos(3.8234,1.2,"../triaxial_stackel_fudge/testloop_v3",1,0);
}

void test_angles(void){
	StackelProlate_PerfectEllipsoid L(12.3e-2, -13.25);
	VecDoub Q = {7.89732,0.,0.0352859,35.,212.1465,87.5689};
	Actions_AxisymmetricStackel_Fudge AAA(&L,-13.25);
	Orbit orbit(&L);
	VecDoub P=orbit.integrate(Q, 10.1, 0.005);
	for(auto i: orbit.results()) printVector(AAA.angles(i));
	return;
}

void test_triax_angles(void){
	StackelTriaxial nfw(3.61/500.,-30.,-20.);
	// VecDoub Q = {0.0001,10.,0.0001,10.,0.01,200.}; //OLAL
	// VecDoub Q =  {0.,0.,4.4,100.01,5.1,0.01};//ILAL
	VecDoub Q = {26.,0.1,0.1,0.,122.,83.1}; // SAL
	// VecDoub Q = {4.,1.,3.,0.01,0.01,0.01}; // BOX
	Actions_TriaxialStackel_Fudge AAA(&nfw,-30.,-20.);
	Orbit orbit(&nfw);
	VecDoub P=orbit.integrate(Q, 0.005, 0.005);
	for(auto i: orbit.results()) printVector(AAA.angles(i));
	return;
}

void test_action_symmetries(void){
	StackelTriaxial nfw(3.61/500.,-30.,-20.);
	VecDoub Q =  {4.,0.0001,4.0001,0.,40.,-40.};
	Actions_TriaxialStackel_Fudge AAA(&nfw,-30.,-20.);
	printVector(AAA.actions(Q));
}

void test_iterative_torus(void){
	GalPot L("../../Torus/pot/PJM11.Tpot");
	VecDoub Q = {7.89732,0.00001,0.0352859,53.428,221.1465,127.5689};
	// Torus *T; T = new Torus;
	// Actions J; J[0]=0.1;J[1]=0.1;J[2]=2.;
	// T->AutoFit(J, L.PWD());
	// Angles Theta; Theta[0]=0.4; Theta[1]=4.5; Theta[2]=2.;
	// Q = findXV(Theta, T, 1);
	// for(int i=3;i<6;i++)Q[i]*=977.775;
	// printVector(Q);
	Actions_AxisymmetricStackel_Fudge AAA(&L,-20.);
	VecDoub actions = AAA.actions(Q);
	printVector(actions);
	IterativeTorusMachine ITM(&AAA,&L);
	ITM.set_dJ(0.001);
	printVector(ITM.actions(Q));

	Orbit orbit(&L);
	VecDoub P=orbit.integrate(Q, 4.5, 0.005);
	printVector(ITM.actions(P));
}

void test_dehnen(void){
	Dehnen Pot(1.,9./4.,31./9.,7./9.,1.);
	double x;
	for(double lx=-1.;lx<2.;lx+=0.1){
		x = pow(10.,lx);
		std::cout<<x<<" "<<Pot.Density({x,0.,0.})<<std::endl;
	}
}

void test_orbit(void){
	NFW Pot(1.,1.,1.,1.);
	VecDoub X = {1.,0.,0.2,0.,0.7,0.3};
	Orbit O(&Pot);
	SymplecticOrbit S(&Pot);
	double tmax = Pot.torb(X);
	O.integrate(X,10.*tmax,tmax/100.);
	S.integrate(X,10.*tmax,tmax/100.,true);
	for(unsigned i=0;i<S.results().size();++i){
		for(auto j:O.results()[i])std::cout<<j<<" ";
		for(auto j:S.results()[i])std::cout<<j<<" ";
		std::cout<<std::endl;
	}
}

void test_action_fudge(void){
	NFW Pot(1.,1.,1.,0.7);
	Actions_AxisymmetricFudge_InterpTables Act(&Pot,"test",true);
}

int main(){
	GalPot G("../Torus/pot/PJM11_best.Tpot");
	Actions_SpheroidalAdiabaticApproximation(&G,"example.saa",true,true,-30.);
//	test_action_fudge();return 0;
//	test_orbit(); return 0;
	test_actions(false); return 0;
	test_dehnen(); return 0;
	runLoops(); return 0;
	// test_iterative_torus(); return 0;
	test_triax_angles(); return 0;
	// test_angles(); return 0;
	// testDelta(); return 0;
	// test_actions(true); return 0;
	runSoS(); return 0;
	runLoops(); return 0;
	// test_action_symmetries(); return 0;

	// MiyamotoNagai M(16.,12.3e6,8.);
	// VecDoub x = {26.0,0.0,0.0,0.0,175.*0.977775,215.*0.977775};
	// std::cout<<M.Vc(8.)<<std::endl;
	// Orbit orbit(&M);
	// VecDoub P=orbit.integrate(x, 4.5, 0.005);
	// orbit.plot(0,1);

	NFW nfw(10.,12.3e5,0.95,0.85);
	// StackelTriaxial nfw(3.61/500.,-30.,-20.);
	lmn_orb lmn(&nfw);
	lmn.readDeltagrids("Delta_withE.dat");
	// testLoop();return 0;
	test_actions(false);return 0;
		// lmn.find_actions(X);
	VecDoub X = {2.,2.,2.,0.1,0.1,0.1};
	Orbit orbit_NFW(&nfw);
	VecDoub QQ=orbit_NFW.integrate(X, 10.5, 0.005);
	// for(auto i: lmn.actionSD(orbit_NFW.results()))std::cout<<i<<" ";std::cout<<std::endl;
	// orbit_NFW.plot(1,2);

	for(auto j:orbit_NFW.results()){for(auto i:lmn.actions(j))std::cout<<i<<" ";std::cout<<std::endl;}

	// std::cout<<nfw.Phi({0.,10.,0.})<<std::endl;
	// lmn.plot_Delta2(nfw.Phi({0.,10.,0.}));
	// lmn.plot_Delta1(nfw.Phi({0.,10.,0.}));
	return 0;
	// Logarithmic nfw(220.,0.9,0.9);
	// double Energy = -72056.5;
	// double x = 9.9;
	// double P = nfw.Phi({x,0.,0.});
	// double p = sqrt(2.*(Energy-P));
	// // StackelTriaxial nfw(3.61/500.,-30.,-20.);
	// // VecDoub X = {26.,0.1,0.1,0.,122.,83.1};
	// // VecDoub X = {4.,1.,.01,0.01,0.01,0.01}; // Box
	// // VecDoub X = {x,0.1,0.1,0.01,p,0.01}; //Short-axis loop
	// // VecDoub X = {0.1,0.1,10.,0.1,146.,0.1}; // Long-axis loop
	// std::cout<<nfw.H(X)<<std::endl;
	// // return 0;
	// Orbit orbit_NFW(&nfw);
	// VecDoub QQ=orbit_NFW.integrate(X, 10.5, 0.05);
	// // orbit_NFW.plot(0,1);
	// // return 0;
	// std::cerr<<nfw.H(X)<<" "<<nfw.H(QQ)<<std::endl;
	// // double a = -80.;
	// for(double a = -50.7;a<-1.;a+=1.){
	// 	// for(double b = -40.2;b<-1.;b+=1.){
	// 	// double a = -28.;
	// 	double b = -14.;
	// 		Actions_TriaxialStackel_Fudge ASTF(&nfw,a,b);
	// 		VecDoub means(3,0),vars(3,0);
	// 		for(auto Y: orbit_NFW.results()){
	// 			// if(a==-50.7 and b==-19.2){
	// 				VecDoub i = ASTF.actions(Y);
	// 				// if(a==-29. and b==-19.)printVector(i);
	// 				means[0]+=i[0];means[1]+=i[1];means[2]+=i[2];
	// 				vars[0]+=i[0]*i[0];vars[1]+=i[1]*i[1];vars[2]+=i[2]*i[2];
	// 				// printVector(i);
	// 			// }
	// 		}
	// 		double L = (double)orbit_NFW.results().size();
	// 		std::cout 	<<a<<" "<<b<<" ";
	// 		std::cout	<<means[0]/L<<" "
	// 					<<means[1]/L<<" "
	// 					<<means[2]/L<<" ";
	// 		std::cout	<<sqrt(vars[0]/L-means[0]*means[0]/L/L)<<" "
	// 					<<sqrt(vars[1]/L-means[1]*means[1]/L/L)<<" "
	// 					<<sqrt(vars[2]/L-means[2]*means[2]/L/L)<<" "<<std::endl;
	// 	// }
	// }
	// // for(auto i:ASTF.actions(QQ))std::cout<<i<<" ";std::cout<<std::endl;
	// return 0;



	// StackelTriaxial T(3.61/500.,-30.,-20.);
	// Orbit orbit(&T);
	// VecDoub x = {14.,.1,7.,50.,160.,150.};
	// Actions_TriaxialStackel AA(&T);
	// std::cout<<T.H(x)<<std::endl;
	// printVector(T.Forces(x));
	// printVector(AA.actions(x,1));
	// // return 0;
	// // printVector(T.Forces(x));
	// VecDoub P=orbit.integrate(x, 60., 0.05);
	// std::cout<<T.H(P)<<std::endl;
	// printVector(P);
	// for(auto i: orbit.results())printVector(i);
	// orbit.plot(0,1, "x_y");
	// orbit.plot(0,2, "x_z");
	// orbit.plot(1,2, "y_z");
	// return 0;



	// Check my fudge code against James' -- it is the same
	// GalPot L("DB97.Tpot");
	// VecDoub Q = {7.89732,0.,0.0352859,353.428,21.1465,87.5689};
	// Actions_AxisymmetricStackel_Fudge AAA(&L,-13.25);
	// VecDoub actions = AAA.actions(Q);
	// printVector(actions);
	// Orbit orbit(&L);
	// VecDoub P=orbit.integrate(Q, 60., 0.05);
	// printVector(conv::CartesianToPolar(P));
	// actions = AAA.actions(P);
	// printVector(actions);



	// for(auto i: orbit.results())printVector(i);
	// orbit.plot(0,1, "x_y");
	// orbit.plot(0,2, "x_z");
	// orbit.plot(1,2, "y_z");
	// Actions_AxisymmetricStackel AAA(&ET);
	// printVector(AAA.actions(x));
	// printVector(actions);
	// VecDoub P=orbit.integrate(x, 20.5, 0.0005);
	// std::cout<<T.H(P)<<std::endl;
	// printVector(P);
	// //orbit.plot(0,1, "x_y");
	// actions = AA.actions(P);
	// printVector(actions);


	// Logarithmic L(220.,0.9);
	// VecDoub x = {26.,0.00001,0.1,0.,142.,83.1};
	// printVector(L.Forces(x));
	// Orbit orbit(&L);
	// VecDoub P=orbit.integrate(x, 2.5, 0.005);
	// orbit.plot(2,3, "z_vx");

	// OblateSpheroidCoordSys S(-5.5);
	// std::vector<VecDoub> pl, l;
	// for(auto i: orbit.results())l.push_back(S.xv2tau(i));
	// for(auto i: l)pl.push_back(S.tau2p(i));
	// VecDoub p1, p2;
	// for(int i=0;i<orbit.results().size();i++){p1.push_back(l[i][0]);p2.push_back(pl[i][0]);}
	// OblateSpheroidCoordSys S2(-55.5);
	// std::vector<VecDoub> pl2, l2;
	// for(auto i: orbit.results())l2.push_back(S2.xv2tau(i));
	// for(auto i: l2)pl2.push_back(S2.tau2p(i));
	// VecDoub p12, p22;
	// for(int i=0;i<orbit.results().size();i++){p12.push_back(l2[i][0]);p22.push_back(pl2[i][0]);}
	// Gnuplot G("points ls 1");
	// G.set_xrange(0.9*Min(p1),1.1*Max(p1)).set_yrange(1.1*Min(p2),1.1*Max(p2));
	// G.savetotex("lv").plot_xy(p1,p2).set_style("points ls 2").plot_xy(p12,p22);
	// G.outputpdf("lv");
	// return 0;
	return 0;
}
